#!/usr/bin/perl -w
use strict;
use warnings;
use File::Basename;
use Getopt::Tabular;

my $profile   = undef;
my ($debug, $verbose) = (0,1);
my $stdout = '';
my $stderr = '';

my @opt_table           = (
    [ "Basic options", "section" ],
    [
        "-profile", "string", 1, \$profile,
        "name of config file in ../dicom-archive/.loris_mri"
    ],
    ["-verbose", "boolean", 1,   \$verbose, "Be verbose."]
);

&Getopt::Tabular::GetOptions( \@opt_table, \@ARGV ) || exit 1;

#####Get config setting#######################################################
{ package Settings; do "$ENV{LORIS_CONFIG}/.loris_mri/$profile" }
##############################################################################

my ($stdoutbase, $stderrbase) = ("$Settings::data_dir/batch_output/imuploadstdout.log", "$Settings::data_dir/batch_output/imuploadstderr.log");



while($_ = $ARGV[0], /^-/) {
    shift;
    last if /^--$/; ## -- ends argument processing
    if (/^-D/) { $debug++ } ## debug level
    if (/^-v/) { $verbose++ } ## verbosity
}


## read input from STDIN, store into array @inputs (`find ....... | this_script`)
my @linearray = ();
my @resultsarray = ();
my @patientname = ();
my @patientnamearray = ();
my @fullpath = ();
my @fullpatharray = ();
my @phantom = ();
my @phantomarray = ();
my @submitted = ();

my $counter = 0;

while(my $line = <STDIN>)
{
    chomp $line;
    my @linearray = split(" " , $line);
    push (@resultsarray, @linearray);
    @patientname = $linearray[0];
    @fullpath = $linearray[1];
    @phantom = $linearray[2];
    push (@patientnamearray, @patientname);
    push (@fullpatharray, @fullpath);
    push (@phantomarray, @phantom);
}
close STDIN;

## foreach series, batch magic
foreach my $input (@resultsarray)
{
    $counter++;
    $stdout = $stdoutbase.$counter;
    $stderr = $stderrbase.$counter;

    #$stdout = '/dev/null';
    #$stderr = '/dev/null';

    my $patientname = $patientnamearray[$counter-1];
    my $fullpath = $fullpatharray[$counter-1];
    my $phantom = $phantomarray[$counter-1];

    ## Ensure that 
    ## 1) the uploaded file is of type .tgz or .tar.gz or .zip
    ## 2) the patient name and path entries are identical; this mimics the imaging uploader in the front-end
    ## 3) check that input file provides phantom details (Y for phantom, N for real candidates)
    my ($base,$path,$type) = fileparse($fullpath, qr{\..*});
    if (($type ne '.tgz') && ($type ne '.tar.gz') && ($type ne '.zip')) {
	print "The file on line $counter is not of type .tgz, tar.gz, or .zip and will not be processed\n";
	exit(1);
    }
    if ($base ne $patientname) {
	print "Make sure the patient name $patientname " .
	      "matches the file name $base in $path\n";
	exit(2);
    }
    if (($phantom eq '') || ($phantom ne 'N') || ($phantom eq 'Y')) {
	print "Make sure the Phantom entry is filled out " .
	      "with Y if the scan if for a phantom, and N otherwise\n";
	exit(3);
    }

    ## this is where the subprocesses are created...  should basically run processor script with study directory as argument.
    ## processor will do all the real magic

    my $command = "$Settings::bin_dir/uploadNeuroDB/imaging_upload_file.pl "
		. "-profile $profile -phantom $phantom -patient_name $patientname $fullpath";
    if ($verbose) {
        $command .= " -verbose";
    }

    ##if qsub is enabled use it
    if ($Settings::is_qsub) {
	     open QSUB, "| qsub -V -e $stderr -o $stdout -N process_imageuploader_${counter}";
    	 print QSUB $command;
    	 close QSUB;
    }
    ##if qsub is not enabled
    else {
         system($command);
    }

     push @submitted, $input;
}
open MAIL, "|mail $Settings::mail_user";
print MAIL "Subject: BATCH_UPLOADS_IMAGEUPLOADER: ".scalar(@submitted)." studies submitted.\n";
print MAIL join("\n", @submitted)."\n";
close MAIL;

## exit 0 for find to consider this -cmd true (in case we ever run it that way...)
exit(0);

